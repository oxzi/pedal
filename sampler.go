package main

import (
	"fmt"
	"time"
)

// intervalSampler reads the Signaler's channel and samples its values to intervals (time.Duration) or passes errors.
func intervalSampler(inputChan chan error, samplingRate time.Duration) (outputChan chan interface{}) {
	outputChan = make(chan interface{})

	go func() {
		var firstInput, lastInput time.Time

		for {
			select {
			case <-time.After(samplingRate):
				if lastInput != (time.Time{}) && lastInput.Add(2*samplingRate).Before(time.Now()) {
					outputChan <- lastInput.Sub(firstInput)

					firstInput = time.Time{}
					lastInput = time.Time{}
				}

			case input := <-inputChan:
				if input != nil {
					outputChan <- input
					return
				}

				if firstInput == (time.Time{}) {
					firstInput = time.Now()
				}
				lastInput = time.Now()
			}
		}
	}()

	return
}

// morseSampler creates morse code words from intervals, generated by intervalSampler.
func morseSampler(inputChan chan interface{}, maxDotDuration, minIdleDuration time.Duration) (outputChan chan interface{}) {
	outputChan = make(chan interface{})

	go func() {
		var tmpWord string
		var lastInput time.Time

		for {
			select {
			case <-time.After(minIdleDuration / 4):
				if tmpWord != "" && lastInput.Add(minIdleDuration).Before(time.Now()) {
					outputChan <- tmpWord

					tmpWord = ""
					lastInput = time.Time{}
				}

			case input := <-inputChan:
				switch input := input.(type) {
				case time.Duration:
					if input <= maxDotDuration {
						tmpWord += "."
					} else {
						tmpWord += "_"
					}
					lastInput = time.Now()

				case error:
					outputChan <- input
					return

				default:
					outputChan <- fmt.Errorf("morseSampler: unsupported type %T", input)
					return
				}
			}
		}
	}()

	return
}
